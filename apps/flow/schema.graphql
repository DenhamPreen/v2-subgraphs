enum ActionCategory {
  Approval
  ApprovalForAll
  Adjust
  Create
  Deposit
  Pause
  Refund
  Restart
  Transfer
  Void
  Withdraw
}

type Action @entity {
  "unique identifier resolving to transaction hash concatenated with the log index (there may be multiple actions per tx)"
  id: ID!

  "transaction details: block number"
  block: BigInt!
  "category of action e.g. Deposit or Withdraw"
  category: ActionCategory!
  "hardcoded chain id"
  chainId: BigInt!
  "contract through which the flowStream actions has been triggered"
  contract: Contract!
  "transaction details: hash"
  hash: Bytes!
  "address that triggered the transaction"
  from: Bytes!

  "flowStream linked to this action (or null if this is a contract level action)"
  flowStream: FlowStream
  "unique global id tracked by the subgraph watcher"
  subgraphId: BigInt!
  "transaction details: timestamp"
  timestamp: BigInt!

  "address of an actor, differs based on action type e.g. for Create it resolves to the sender"
  addressA: Bytes
  "address of an actor, differs based on action type e.g. for Transfer it resolves to the new recipient"
  addressB: Bytes
  "amount, differs based on action type e.g. for Deposit it resolves to the depositAmount"
  amountA: BigInt
  "amount, differs based on action type e.g. for Withdraw it resolves to the refundedAmount"
  amountB: BigInt
}

type Asset @entity(immutable: true) {
  "unique identifier resolving to the ERC20 asset/token address"
  id: ID!

  "address of the ERC20 asset/token"
  address: Bytes!
  "hardcoded chain id"
  chainId: BigInt!
  "decimals of the ERC20 asset/token"
  decimals: BigInt!
  "name of the ERC20 asset/token"
  name: String!
  "symbol of the ERC20 asset/token"
  symbol: String!

  "flowStreams that rely on this asset/token"
  flowStreams: [FlowStream!]! @derivedFrom(field: "asset")
}

type Batch @entity {
  "unique identifier of the batch, resolving to the hash of the parent transaction"
  id: String!
  "number of flowStreams that are part of this batch"
  size: BigInt!
  "index of the batch resolving to a conditional counter of 2+ flowStream batches, filtered by sender (label is null for batches containing a single flowStream, for filtering)"
  label: String
  "batcher (sender) that started this batch"
  batcher: Batcher
  "flowStreams that are part of this batch"
  flowStreams: [FlowStream!]! @derivedFrom(field: "batch")
  "hash of the transaction that created this batch"
  hash: Bytes!
  "timestamp of the transaction that created this batch"
  timestamp: BigInt!
}

type Batcher @entity {
  "unique identifier of the batcher (sender), resolving to their address"
  id: String!
  "address of the sender"
  address: Bytes!
  "numeric index, will be used to construct the batch label"
  batchIndex: BigInt!
  "batches started by this batcher (sender)"
  batches: [Batch!]! @derivedFrom(field: "batcher")
}

type Contract @entity {
  "unique identifier resolving to contract address"
  id: String!

  "full version based on the SablierFlow contract versioning system"
  version: String!
  "hardcoded alias, resolved by replacing the contract address from the id with the contract alias"
  alias: String!
  "address of the contract"
  address: Bytes!
  "address of the contract admin"
  admin: Bytes
  "flowStreams created through this contract"
  flowStreams: [FlowStream!]! @derivedFrom(field: "contract")
  "actions on flowStreams, triggered through this contract"
  actions: [Action!]! @derivedFrom(field: "contract")
}

type FlowStream @entity {
  "unique identifier for the flowStream, resolving to the origin contract address concatenated with the chainId and the tokenId"
  id: String!

  "hardcoded alias, resolved by replacing the contract address from the id with the contract alias"
  alias: String!
  "unique global id tracked by the subgraph watcher - ðŸš¨ these may change if new contracts are added and the chronological order of flowStream changes"
  subgraphId: BigInt!
  "unique identifier for the flowStream released by the origin contract - same as the tokenId or streamId values given by the contract"
  tokenId: BigInt!
  "full version based on the SablierFlow contract versioning system"
  version: String!

  "hardcoded chain id"
  chainId: BigInt!
  "contract through which this flowStream has been created"
  contract: Contract!
  "transaction hash for the flowStream creation"
  hash: Bytes!
  "timestamp of the flowStream creation (for sorting reasons)"
  timestamp: BigInt!

  "manager of the flowStream, defined at creation"
  sender: Bytes!
  "current recipient of the flowStream, can withdraw the funds (the recipient can change on flowStream/nft transfer)"
  recipient: Bytes!

  "asset (ERC20 token) supported by this flowStream"
  asset: Asset!

  "timestamp for the start of the flowStream"
  startTime: BigInt!
  "timestamp of the date until the flowStream is solvent"
  solvencyTime: BigInt!
  "flag showing the transferability of the flowStream (decided when the flowStream is created)"
  transferable: Boolean!
  "flag showing if a flowStream is paused"
  paused: Boolean!

  "current balance of the flowStream"
  balance: BigInt!
  "current ratePerSecond of the flowStream"
  ratePerSecond: BigInt!
  "amount resolving to the sum of all deposits"
  depositedAmount: BigInt!
  "amount resolving to the sum of all withdrawals"
  withdrawnAmount: BigInt!
  "amount resolving to the streamed amount up until the ratePerSecond is changed"
  streamedAmount: BigInt!

  "actions triggered in the context of this flowStream"
  actions: [Action!]! @derivedFrom(field: "flowStream")
  "batch the flowStream is part of, only available when created within a batch create transaction"
  batch: Batch!
  "position in the batch, only available when created within a batch create transaction"
  position: BigInt!

  "amount of fees paid to the broker"
  brokerFeeAmount: BigInt!
  "amount of fees paid to the protocol"
  protocolFeeAmount: BigInt!
}

type Watcher @entity {
  "unique identifier for the watcher, resolving to the chainId - there is one watcher for entire subgraph"
  id: String!
  "hardcoded chain id"
  chainId: BigInt!
  "global index for flowStreams"
  flowStreamIndex: BigInt!
  "global index for flowStream"
  actionIndex: BigInt!
  "flag that defines the initialization status of the subgraph"
  initialized: Boolean!
  "list of logs, for debugging purposes"
  logs: [String!]!
}
